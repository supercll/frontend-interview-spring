<a name="7dpW0"></a>
# 网络分层
- OSI分层：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 
- TCP/IP模型：应用层、传输层、网络层、网络接口层 
- 应用层协议(常用)：HTTP、RTSP、FTP 
- 传输层协议：TCP、UDP



<a name="PG3Hu"></a>
## cookie是什么，cookie的用处 

- cookie是存储在客户端浏览器中的客户端的技术
- 实现客户端与服务器之间状态的保持
- 可以用于存储用户信息，比如说登陆状态等
<a name="DLjgn"></a>
# 常见状态码

- 201 created，我在我的项目中用于用户或者资源的创建成功时返回
- 204 no content ，项目中用于资源的修改或者删除成功时返回
- 301 永久性重定向，配合location字段
- 302 临时性重定向。区别就是是否请求服务器的区别
- 304 no modified 协商缓存相关的状态码，当协商缓存生效时返回304，表示浏览器从本地缓存中获取资源
- 401 要求验证身份，在登陆时返回
- 403 forbidden 表示没有权限，当资源与用户不对应的时候返回
- 409 conflict 表示资源冲突，项目中用于当用户名创建重复时返回
- 422 请求参数异常，获取图片异常时返回
- 500 服务端错误，504 网关超时



<a name="Z6zwz"></a>
# post和get的区别

- post相对于get要安全一些，因为get是基于url传输，post是基于http request传输
- post能传输更多的数据格式，传输的数据量比较大
- get在浏览器回退时是无害的，而post会再次提交，post请求不能缓存，get能缓存
- Post 支持**更多的编码类型**且不对数据类型限制<br />
- GET 在浏览器回退时是无害的，而 POST 会再次提交



<a name="382i2"></a>
# RestfulAPI


- 是一种新的API 设计方法
- 传统API是把每个url当做一个功能
- Restful API 是把每个URL当做一个唯一的资源
   - get 获取数据
   - post 新建数据
   - patch/put 提交数据
   - delete 删数据



<a name="qtCzF"></a>
# 从输入url到浏览器渲染页面之间发生了什么

1. 解析url对应的域名
1. 缓存检查-（比如说强缓存，协商缓存，本地存储）
1. 通过DNS解析出域名对应的外网IP地址
1. 通过三步握手建立TCP连接，目的，浏览器与服务器之间建立一个稳定可靠的传输通道
1. HTTP的请求与响应
1. 通过四次挥手断开TCP连接
   1. 减少握手时间会设置Connection: keep-alive响应头字段表示长连接
7. 浏览器拿到HTTP响应报文实现客户端渲染
   1. 处理HTML 标记，生成DOM树
   1. 处理css标记，生成CSS OM树
   1. 通过拿到的DOM树和CSSOM树生成render树
   1. 根据生成的render树计算HTML结点在视口的确切位置和大小，这个计算阶段就是回流重绘
   1. 根据计算得到的结果绘制页面


<br />

<a name="SG5cl"></a>
## DNS解析

- 递归查询
   - 客户端-浏览器缓存-本地host文件-本地DNS解析器缓存-本地dns服务器
- 迭代查询
   - 客户端-本地DNS服务器 
      - 根域名服务器
      - 顶级域名服务器
      - 权威域名服务器
- DNS解析事件预计时间20-120ms
   - 减少DNS请求，多服务器部署，增加了DNS解析的次数，提高了HTTP的并发性能
   - DNS预请求：dns-Prefetch
- 如果一个页面的域名多
```html
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="//static.360buyimg.com"/>
<link rel="dns-prefetch" href="//misc.360buyimg.com"/>
<link rel="dns-prefetch" href="//img10.360buyimg.com"/>
<link rel="dns-prefetch" href="//d.3.cn"/>
<link rel="dns-prefetch" href="//d.jd.com"/>
```
浏览器遇到link标签是单独开辟一个线程加载资源，这样的话等到真正需要调用资源的时候就已经早已加载完成，所以这就是dns资源的预加载<br />

<a name="Jh5Lb"></a>
### 长轮询与长链接

- 长轮询：设置定时器，每间隔一段时间发送一次请求，拿到最新数据
   - 如果没有数据更新，还是会从小请求，重新渲染
- 长连接：是一个服务器挂起的操作
   - 第一次发请求就会验证数据是否更新，如果没有更新就不会中断连接，进行挂起监听
   - 监听到有数据更新时再返回客户端，并且客户端会再立即发送一个请求给服务器继续监听



<a name="S5B9q"></a>
## 缓存控制

- 首先说一下强缓存吧
   - expire字段其实就是GMT格式的绝对过期时间，这个字段有一个bug，就是GMT可以通过修改用户本地时间修改，所以现在由cache-control字段替代
   - cache-control就是一个毫秒为最小单位的相对过期时间
- 然后是协商缓存，同样有两个字段
   - last-modified，以秒为最小单位的文件修改时间，这个字段只能精确到秒，而且不能对文件内容进行一个精确监控
   - etag，是存储的文件的hash值，文件一旦修改，那么hash值就一定会变，每次只需要比对if-none-match就能判断是否需要更新资源
- 现在都是强缓存和协商缓存共同控制缓存信息
<a name="L4VBY"></a>
### 问题
本地缓存了文件，但是服务器的资源更新了，如何保证获取到的是最新的内容？

- 请求资源的时候设置时间戳
   - 第一次 `<link href='index.css?20210224215800'>`
   - 如果服务器资源有更新，再次发请求，保证时间戳不一样，这样就不会走本地的强缓存了，而是从新拉取最新的资源
   - `<link href='index.css?20210227000000'>`
- 文件添加HASH后缀
   - 这种方式在webpack很常用，如果服务端文件更新，那么对应的hash值也会变化
<a name="hQ6o9"></a>
### 客户端存储方案

- 全局变量存储：【vuex、redux】，但是页面一刷新就会被释放
- 本地存储
   - cookie
   - webStorage：localstorage，sessionStorage
   - indexDB：浏览器数据库 【以下不常用】
   - cache：缓存
   - manifest：H5的离线存储，静态资源，但是性能不好，轻量存储



<a name="qCr8k"></a>
### 本地存储的区别
**localStorage与sessionStorage**

- local 持久化本地存储，不会自动清除
- sessionStorage：根据语义化来分析，会话存储，关闭了当前的页面会话，那么就会清除存储


<br />**localStorage vs sessionStorage**

- 本地存储的数据是由同源访问限制的，只允许同源读取
- cookie只允许一个源下最多4kb的内容，localstorage可以5MB甚至更多
- cookie需要设置过期时间，自动失效，并且有路径限制【指定路径才能够访问】，localStorage除非自己手动清除
- cookie不稳定，基于安全卫士或者浏览器自带的清除操作，会让cookie失效；浏览器无痕模式也会使其失效
- cookie兼容低版本浏览器



<a name="6BTms"></a>
## 网路性能优化汇总

- 利用缓存
   - 对于静态资源文件实现强缓存和协商缓存（扩展：文件有更新，如何保证及时刷新？）  
   - 对于不经常更新的接口数据采用本地存储做数据缓存（扩展：cookie / localStorage / vuex|redux 区别？）
- DNS优化
   - 分服务器部署，增加HTTP并发性（导致DNS解析变慢）
   - DNS Prefetch
- TCP的三次握手和四次挥手
   - Connection:keep-alive
- 数据传输
   - 减少数据传输的大小
   - 内容或者数据压缩（webpack等）
   - 服务器端一定要开启GZIP压缩（一般能压缩60%左右）
   - 大批量数据分批次请求（例如：下拉刷新或者分页，保证首次加载请求数据少）
   - 减少HTTP请求的次数 
   - 资源文件合并处理
   -  字体图标
   -  雪碧图 CSS-Sprit
   -  图片的BASE64
- CDN服务器“地域分布式”
- 采用HTTP2.0
<a name="jkzhb"></a>
# TCP的三步握手与四次挥手

- 三步握手
   - 首先客户端会发送报文给服务端，携带了SYN请求字段，seq请求序号，进入`**sent**`阶段
   - 服务端接收到报文后做出响应，携带响应字段ACK，响应序号ack为seq + 1，表示对应关系，同时也会发送SYN,以及seq，进入`**received**`阶段
   - 客户端接收到了响应后，此时已经建立了完整的连接了，返回ACK确认字段 ,以及ack，seq序号，此时进入`**established**`状态
   - 三步握手是建立连接的最小步骤，就和平时通话一样，必须得三次的相互询问才能确认建立了完整的连接
- 四步挥手
   - 客户端发送FIN终止字段，seq序号，进入`fin - wait1`阶段
   - 服务端接收之后表示知道了，返回ACK确认字段以及ack序号，同时预留时间关闭服务，进入`close——wait2`阶段
   - 等待服务关闭完成后，再发送FIN字段，seq序号，ACK确认字段，ack序号，进入`last-ack`阶段
   - 客户端接收到关闭完成的确认后返回ACK确认收到，ack序号，此时连接正式关闭
   - 四次挥手是由于关闭服务需要时间，所以有一次是收到关闭请求，有一次是确认关闭完成的确认消息



<a name="5WutI"></a>
# HTTP
<a name="exKRw"></a>
## HTTP的发展
<a name="mxbbv"></a>
### HTTP 1.1
**优点**<br />

1. 复用链接（**持久连接**），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延
   1. Connection： keep-alive
2. **管线化**，一个请求之后可以不等待响应，继续下一个请求
2. 格外的缓存机制，状态码，提交方法以及内容协商机制等


<br />**缺点**

1. 请求头复杂冗余且重复，数据未强制压缩，浪费资源和性能
1. 只能客户端发送请求，不能服务端主动发起，比如聊天时，客户端需要不断发送请求
1. 请求没有优先级，无法首先加载重要资源
1. 每个域名下的请求并行数量有限制



<a name="wG50T"></a>
### HTTP 2.0

1. **二进制格式传输**，取代了 HTTP1 的文本格式，二进制格式解析更高效
1. **多路复用**，**就是在一个 TCP 连接中可以存在多条流,**处理多个请求
1. 强制压缩**HTTP Header**
1. 服务器推送（server push）允许服务器未经请求，主动向客户端发送资源，减少延迟时间
1. 设置请求的优先级



<a name="egSFj"></a>
### HTTPS

- 对称加密算法的特点是 速度快，不安全，加密解密使用**同一个共享密匙**
- 非对称加密特点是 速度慢，安全，公密匙加密，私密匙解密
- 所以一般都是两者混用：
   1. 使用对称加密的**共享密钥加密数据**
   1. 浏览器通过非对称加密的**公密匙加密这个共享密钥**，传输给服务器
   1. 服务器通过**私密匙解密出对称加密的共享密钥**，再使用这个**共享密钥解密数据**
- 而加密共享密匙用的公密匙一般是服务器提供
<a name="xlV3E"></a>
### HTTPS加密算法


- 对称加密算法的特点是 速度快，不安全，加密解密使用**同一个共享密匙**
- 非对称加密特点是 速度慢，安全，公密匙加密，私密匙解密
- 所以一般都是两者混用：
   1. 使用对称加密的**共享密钥加密数据**
   1. 浏览器通过非对称加密的**公密匙加密这个共享密钥**，传输给服务器
   1. 服务器通过**私密匙解密出对称加密的共享密钥**，再使用这个**共享密钥解密数据**
- 而加密共享密匙用的公密匙一般是服务器提供



<a name="4da14316"></a>
### **TLS的握手方式**

<br />因为无法确定得到的公密匙就是服务器发送的，可能会有坏人截取，发送坏人自己的公密匙，浏览器发送加密数据后，坏人通过自己的私密匙解密<br />
<br />因此就产生了**TLS的握手方式**<br />**<br />简单来说：

1. 有一个第三方机构来证明公匙的可靠性
1. 三方机构给客户端发送证书
1. 客户端把这个证书发给服务端，服务端使用证书上的公匙加密
<a name="3imps"></a>
## HTTP1.x与HTTP2.0


- 1.1 相对于1.0有几个优点
   - 持久连接，就是请求头中的connect字段为keep-alive，一次TCP连接可以有多个HTTP请求与响应
   - 管线化处理，一次的HTTP请求可以不等待响应，继续下一次的HTTP请求
   - 更多的状态码以及缓存机制
- 但是仍旧有许多缺点
   - HTTP首部未进行强制压缩，浪费资源和性能
   - 没有server push，有一定的延迟
   - 没有请求的优先级
   - 域名下的并行数量有限制
- 2.0就对1.1进行了一个升级
   - 他是基于二进制格式传输的，相比1.1的文本格式解析更加高效
   - 强制压缩了HTTP首部
   - server push 服务端推送，能够减少一定的延迟
      - 例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端
      - 当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了
   - 多路复用，意思就是一个TCP下有多条流，能同时处理多个请求，也就是一个链接通道可以同时多个请求



<a name="vMrWs"></a>
## HTTP与HTTPS

- HTTP的特点是
   - **无状态**：协议对客户端**没有状态存储**，比如访问一个网站需要**反复进行登录操作**
   - **无连接**：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。HTTP1.1诞生了connection: keep-alive **长连接**机制，一次连接可以多次请求与响应
   - **基于请求和响应**：基本的特性，由客户端发起请求，服务端响应
   - **通信使用明文、简单快速、灵活**
- HTTPS 是经由HTTP进行通信，利用**SSL/TLS建立全信道**，加密数据包。
- HTTPS的特点
   - 数据进行了混合加密技术
   - 通过证书进行身份验证
   - 保护数据的完整性-防止传输的内容被中间人冒充或者篡改
- HTTPS的加密方式
   - 对称加密与非对称加密混合使用
   - TLS握手确保加密的安全性：利用了第三方机构颁发的证书来确保加密公钥的安全性



<a name="SWIe7"></a>
# TCP与UDP的区别

- tcp 
   - 可靠稳定，但是速度慢
   - TCP是面向链接的，提供可靠服务，面向字节流，基于双工通道的可靠连接
- udp
   - 快速简单的广播机制，但是不不可靠不稳定
   - UDP是无连接的，支持一对多，基于不可靠通道
- 适用场景
   - udp适用于效率要求高，QQ聊天，在线视频，网络电话等
   - tcp适用于准确性高的：文件传输,HTTP的请求与响应等等


<br />

<a name="Jd2QF"></a>
# web安全
<a name="OSxeS"></a>
## csrf

- 就是Cross Site Request Forgery翻译为跨站请求伪造
- 他的基本原理就是用户登录网站时会得到网站提供的cookies，相当于身份信息
- 有恶意用户会通过各种方式拿到这个cookie来伪造身份对用户信息甚至网站进行修改
- 他的防范方法是通过
   - 同源检测，http请求头中通过origin referer信息来判断
   - 通过post修改数据而不用get
   - 通过token、或者验证码来检测用户提交
   - 可以对 Cookie 设置 SameSite 属性，限制不能作为三方使用，严格模式下不允许任何三方
<a name="15lGv"></a>
## xss

- 是crose site scripting，跨站脚本伪造
- 基本原理是利用了网站对用户信息过滤不足的缺点添加一些脚本嵌入到网站中去
- 分类
   - 反射型：通过url直接注入
   - 存储型：攻击嵌入网页的代码会被保存到数据库
- 可被利用的标签有a，script，input，img标签等等
- 防范方法就是加强对用户输入的一个过滤
   - **Cookie**设置 **httpOnly，使得脚本无法获取cookie**
   - **设置CSP，建立白名单**
   - 使用转义字符
<a name="KskCK"></a>
## 跨域

- 跨域也算是一个安全问题吧，这是浏览器规定的同源策略
- 协议、域名以及端口号都相同才是同源       
- 跨域请求的方式可以通过JSONP，设置cors响应头acces-control-allow-origin来放行指定url，设置代理实现跨域，webpack的代理，或者nginx代理
